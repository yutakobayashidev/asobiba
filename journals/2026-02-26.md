## Codex App Server プロトコルを Go クライアントから叩いてみた

Codex app-server は JSON-RPC 2.0 over stdio で通信する。MCP と同じ方式だが、`"jsonrpc":"2.0"` ヘッダーはワイヤー上で省略される独自仕様。

### プロトコルの流れ

```
initialize (request) → initialized (notification) → model/list → thread/start → turn/start → イベントストリーム → turn/completed
```

- `initialize` + `initialized` のハンドシェイクが必須。これを送る前の全リクエストは拒否される。
- `thread/start` でスレッド（会話）を作り、`turn/start` でユーザー入力を送る。レスポンスは `turn/completed` まで notification として流れてくる。

### つまずいたポイント

**モデル名が ChatGPT サブスクで使えない場合がある。** `codex-mini` を指定したら `"The 'codex-mini' model is not supported when using Codex with a ChatGPT account."` エラー。`model/list` で利用可能モデルを先に確認すべき。サブスクでは `gpt-5.3-codex` がデフォルトだった。

**`sandbox` パラメータは thread/start では文字列、turn/start ではオブジェクト。** thread/start に `{"type": "workspaceWrite", ...}` のようなオブジェクトを渡したら `"invalid value: map, expected map with a single key"` エラー。正しくは `"workspace-write"` という kebab-case 文字列。ドキュメント上の例は camelCase (`workspaceWrite`) だが、実際のワイヤーフォーマットは kebab-case。

```go
// NG: thread/start ではオブジェクト形式は受け付けない
"sandbox": map[string]interface{}{"type": "workspaceWrite", ...}

// NG: camelCase も不正
"sandbox": "workspaceWrite"

// OK: kebab-case の文字列
"sandbox": "workspace-write"
```

**承認フロー（approval）はサーバー起点の JSON-RPC リクエスト。** `item/commandExecution/requestApproval` は通常の notification ではなく `id` を持つ request であり、クライアントが `{"id": <same-id>, "result": "accept"}` のようなレスポンスを返す必要がある。`approvalPolicy: "never"` を使えばこのフロー自体をスキップできる。

### イベントストリームの構造

ターン中に大量の notification が流れてくる。重要なものを整理:

| メソッド | 用途 |
|---------|------|
| `item/agentMessage/delta` | エージェントのテキスト応答（ストリーミング） |
| `item/reasoning/summaryTextDelta` | 推論プロセスの要約テキスト |
| `item/started` (type: commandExecution) | コマンド実行開始 |
| `item/commandExecution/outputDelta` | コマンドの stdout/stderr |
| `item/started` (type: fileChange) | ファイル変更提案 |
| `item/commandExecution/requestApproval` | コマンド承認リクエスト（要レスポンス） |
| `turn/completed` | ターン完了シグナル |
| `thread/tokenUsage/updated` | トークン使用量 |

`codex/event/*` 系（レガシー）と `item/*` / `turn/*` 系（v2）の両方が同時に流れてくる。クライアントは v2 系だけ見ればよい。

### Go 実装の設計判断

- `map[string]json.RawMessage` を受信の共通型にして、`method` や `id` の有無で request/notification/response を判別。型安全性は犠牲にするが、プロトタイプには十分。
- セットアップ中（initialize 〜 thread/start）は `waitResp` で同期的にレスポンスを待ち、対話ループ中は `processTurn` でイベントを逐次処理する二段構成。
- goroutine でサーバー stdout → channel、ユーザー stdin → channel の2本を非同期に読み、main goroutine で調停。
